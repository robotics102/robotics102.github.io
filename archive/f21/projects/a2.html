<!DOCTYPE HTML>
<!--
  Editorial by HTML5 UP
  html5up.net | @ajlkn
  Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>ROB 102 F21: Project 2</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/assets/css/main.css" />
    <link rel="shortcut icon" type="image/png" href="/assets/images/icon.png"/>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/stackoverflow-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body class="is-preload">

    <!-- Wrapper -->
      <div id="wrapper">

        <!-- Main -->
          <div id="main">
            <div class="inner">

              <!-- Header -->
              <header id="header">
                <a href="/index.html" class="logo"><strong>ROB 102:</strong> Introduction to AI and Programming</a>
                <ul class="icons">
                  <li><a href="https://um-fa22-rob102.slack.com" class="icon brands fa-slack" target="_blank"><span class="label">Slack</span></a></li>
                  <li><a href="https://github.com/robotics102" class="icon brands fa-github" target="_blank"><span class="label">GitHub</span></a></li>
                </ul>
              </header>

              <!-- Content -->
  <section>
    <header class="main project">
      <strong>Project 2:</strong> Potential Field Navigation
    </header>

    <p><font size="+2"><strong>Due November 1st, 2021 at 11:59 PM.</strong></font></p>

    <p>In <a href="a1.html">Project 1</a>, we saw that we can control the robot to maintain a goal distance to the wall by correcting the control signals based on the observed sensor data. Now, we want the robot to be able to autonomously navigate to a goal location.</p>

    <p><span class="image left"><img src="/assets/images/p2/potential_field.png" alt=""/></span>
      In Project 2, we will accomplish autonomous navigation using <strong>potential field control</strong>. We can imagine that our goal is a magnet, pulling the robot towards it. We can treat obstacles like repelling forces, pushing the robot away. If we combine these two forces, we might get a potential field that looks like the example on the left. To get to the goal, our robot can follow the path of least resistance, moving in the direction of the strongest force at its location at each time step.</p>

    <p>For this project, you will write code in C++ to calculate the potential fields the robot needs to reach a goal without colliding with any obstacles. You will be given a map which tells you where the obstacles are, along with a start and goal position. </p>

    <p>This project will be done in teams of 2 or 3. The instructors will assign teammates.</p>

    <ul>
      <li><a href="#getting_code">Getting the Code</a>
      <li>
        <a href="#submitting">Submitting the Assignment</a>
        <ul>
          <li><a href="#grading">Grading Breakdown</a></li>
        </ul>
      </li>
      <li>
        <a href="#code">Code Overview</a>
        <ul>
          <li><a href="#code_web">Running the Webapp in the Docker</a></li>
          <li><a href="#code_robot">Running Potential Field Navigation on the Robot</a></li>
          <li><a href="#code_utils">Provided Utility Functions</a></li>
        </ul>
      </li>
      <li><a href="#proj_desc">Project Description</a>
        <ul>
          <li><a href="#sec_graph">Part 0: Grid Graph</a></li>
          <li><a href="#sec_goal">Part 1: The Goal Field</a></li>
          <li><a href="#sec_dt">Part 2: Distance Transform</a></li>
          <li><a href="#sec_pfield">Part 3: Potential Field Navigation</a></li>
          <li><a href="#sec_euclidean_dt">Advanced Extension: Euclidean Distance Transform</a></li>
          <li><a href="#sec_results">Project Webpage: Results &amp; Reflection Questions</a></li>
        </ul>
      </li>
      <li><a href="#tasks">Task Summary</a></li>
      <li><a href="#adv_ext">Advanced Extensions</a></li>
    </ul>

    <hr class="major" />

    <h2 id="getting_code">Getting the Code</h2>

    <p>One repository per team will be created for this project. All teammates will have access to the repository and will be able to view it and make changes. All teammates will share ownership of the code and receive credit for writing the code through the license file.</p>

    <p><strong>The invite link to accept the assignment on Github Classroom can be found on Slack.</strong></p>

    <p>Create a GitHub Classroom team named <strong>P2 UM Team &#35;</strong> for UM students, and <strong>P2 Berea Team &#35;</strong> for Berea students. Replace <strong>&#35;</strong> with the team number assigned to you. See <a href="a1.html#getting_code">Project 1 instructions</a> for more details.</p>

    <p>Some parts of the provided code run on your comupter, in a Docker container. Others run on the robot. You will be cloning the repository on both your computer and the robot. This command clones the repository:</p>
    <pre><code class="language-bash">git clone &lt;ADDRESS&gt;</code></pre>
    <p>Substitute the address to your repository. On the robot, run this command in the home directory of the Raspberry Pi, in a terminal opened in a VSCode remote session to the robot (see the <a href="/tutorials/robot.html#sec_conn_robot">robot tutorial</a>). <strong>Use the SSH address to clone the repository on the robot</strong> (see instructions <a href="/tutorials/robot.html#sec_code_robot">here</a>).</p>

    <p>On your computer, run the clone command <strong>in the folder you created for ROB 102 code in Project 0</strong>. For most of you, that is a folder called &quot;rob102-code&quot;, or something similar, in your Documents folder. Use <code>cd</code> in your terminal to go to this folder before running the clone command.</p>

    <hr class="major" />

    <h2 id="submitting">Submitting the Assignment</h2>

    <p>Your submission for this assignment should include your code and a project webpage. You should make one submission for your team. Teammates will be graded together.</p>

    <p><strong>Modify the LICENSE.txt file to include the names of all teammates.</strong> Make sure the change is committed to your repository. </p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo1">P2 License:</strong> In the file <code>LICENSE.txt</code>, replace <code>&lt;COPYRIGHT HOLDER&gt;</code> with the names of all teammates, separated by commas. Replace <code>&lt;YEAR&gt;</code> with the current year.
      </li>
    </ul>

    <p><strong>Submitting the code:</strong> Tag the verion of the code you wish to submit. See instructions from <a href="a0.html#submitting">Project 0</a>.</p>

    <p><strong>Submitting the web page:</strong> Create a web page for your implementation of the potential field navigation algorithm. You can use Google Sites, create a project page on a GitHub repository, or use your favorite method to create a website. Note that if you chose to use GitHub pages, you will need to create a separate, public repository. Include at least one video demo as well as a brief summary and discussion of your algorithm. Details about what to include can be found <a href="#sec_results">at the end of the project description</a>. Include the link to your project page in the <code>README.md</code> file.</p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo1">P2 Webpage:</strong>
        Create a web page for your implementation of the potential field navigation algorithm. Include the link to your project page in the <code>README.md</code> file. Include at least one video demo as well as a brief summary and discussion of your algorithm.
      </li>
    </ul>

    <h3 id="grading">Grading Breakdown</h3>

    <p>This project will be graded as follows:</p>
    <ul>
      <li>
        <strong>Attractive Field Navigation Live Demo (in-class):</strong> (2 points)
        <a href="#sec_goal">Part 1</a> of the project will be demonstrated on the robot, in class on October 27th.
      </li>
      <li>
        <strong>Potential Field Navigation Live Demo (in-class):</strong> (2 points)
        <a href="#sec_pfield">Part 3</a> of the project will be demonstrated on the robot, in class on November 3rd.
        You can use whichever implementation of the distance transform and potential field you choose.
      </li>
      <li>
        <strong>Attractive Field Navigation Video Demo:</strong> (2 points)
        On your website, include at least one video of your robot navigating with an attractive field, as described in <a href="#sec_goal">Part 1</a>.
        For full credit, include multiple examples of start and goal locations, and maps.
      </li>
      <li>
        <strong>Distance Transform Photo Demo:</strong> (3 points)
        On your website, include photos of all implementations of your distance transform, as described in <a href="#sec_dt">Part 2</a> (you can take screenshots of the web app).
        For full credit, include multiple examples of maps.
      </li>
      <li>
        <strong>Potential Field Navigation Video Demonstration:</strong> (3 points)
        On your website, include at least one video of your robot navigating with a potential field, as described in <a href="#sec_pfield">Part 3</a>.
        You can use whichever implementation of the distance transform and potential field you choose.
        Please make the method you used to create the video clear on your website. For full credit, include multiple examples of start and goal locations, and maps.
        You might also consider including examples of failure cases.
      </li>
      <li>
        <strong>Discussion:</strong> (3 points)
        On your website, include a brief discussion and analysis of your design choices (see <a href="#sec_results">reflection questions</a>).
      </li>
    </ul>

  </section>

  <section id="code">
    <header class="major">
      <h2><a href="#code">Code Overview</a></h2>
    </header>

    <p>There are three different code executables that can be run for Project 2:</p>
    <ol>
      <li>
        <strong>Navigation web server:</strong>
        This code is stored in <code>src/web_server.cpp</code> and runs <em>in the Docker container</em>, running on your laptop.
      </li>
      <li>
        <strong>Robot potential field navigation:</strong>
        This code is stored in <code>src/robot_potential_field.cpp</code> and runs <em>on the robot</em>.
      </li>
      <li>
        <strong>Tests:</strong>
        There is one test for Project 2, for Part 0, that is written in <code>src/tests/test_graph.cpp</code> and runs <em>in the Docker container</em>, running on your laptop.
      </li>
    </ol>

    <h3 id="code_web">Running the Webapp in the Docker</h3>

    <p>Follow the instructions in the <a href="/tutorials/app.html">Webapp Tutorial</a>. There is also a video demonstration linked on Slack.</p>

    <h3 id="code_robot">Running Potential Field Navigation on the Robot</h3>

    <p>The code to perform potential field navigation on the robot is in <code>src/robot_potential_field.cpp</code>. Before you run the code, you should <a href="/files/labs/lab4_navigation_workflow.pdf">make a map</a> of the environment you want to run in. Then, run the localization using the map you just made (see <a href="/files/labs/lab5_potential_field_nav.pdf">Lab 5</a>).</p>

    <p>To compile and run potential field navigation on the robot, connect to the robot using VSCode (as described in the <a href="/tutorials/robot.html#sec_robot_prog">robot tutorial</a>). Then, from inside the repository you cloned onto the robot for Project 2, compile as follows:</p>
    <pre><code class="language-bash">cd build
cmake -DOMNIBOT=On ..
make</code></pre>
    <p>Do not forget the argument <code>-DOMNIBOT=On</code> when running CMake. This is how the compiler knows whether to compile the robot code (which is not compiled by default in the Docker). To run the potential field controller, in the <code>build</code> folder where you compiled, do:</p>
    <pre><code class="language-bash">./robot_potential_field [PATH/TO/MAP] [goal_x] [goal_y]</code></pre>
    <p>The map is stored in <code>~/botlab-bin/maps/current.map</code>. Use that path if you did not move the map since creating it. You can also pass in <code>goal_x</code> and <code>goal_y</code>, the global position of the goal, relative to the starting position of your map, in meters. If you do not pass these in, they will default to zero.</p>

    <p>When you pass in arguments to the code, do not include the square brackets.</p>

    <h3 id="code_utils">Provided Utility Functions</h3>

    <p>To use provided functions, all you need to do is include the correct header file. The needed header files should already be included in the templates. Check the header files (in folder <code>include/autonomous_navigation/</code>) for all the functions available, and the associated documentation. Some robot functions, including <code>drive(vx, vy, wz)</code>, and some other helpers, are the same as in <a href="a1.html#code">Project 1</a>. Below are a few of the functions you will likely find helpful, from the header <code>include/autonomous_navigation/utils/graph_utils.h</code> (implemented in <code>src/utils/graph_utils.cpp</code>). Other than those marked, these are implemented for you.</p>

    <ul class="hint">
      <li class="icon solid fa-cogs">
        <code>int cellToIdx(int i, int j, const GridGraph& graph)</code>:
        <em>(TODO, see <a href="sec_graph">Part 0</a>)</em> Given a cell row <code>i</code> and column <code>j</code> in the graph, calculates the index where the data for the cell is stored.
      </li>
      <li class="icon solid fa-cogs">
        <code>Cell idxToCell(int idx, const GridGraph& graph)</code>:
        <em>(TODO, see <a href="sec_graph">Part 0</a>)</em> Given an index, calculates the corresponding cell row <code>i</code> and column <code>j</code> in the graph.
      </li>
      <li class="icon solid fa-cogs">
        <code>bool loadFromFile(const std::string& file_path, GridGraph& graph)</code>:
        Loads graph data from a file. Calls the <code>initGraph()</code> function.
      </li>
      <li class="icon solid fa-cogs">
        <code>void initGraph(GridGraph& graph)</code>:
        Initializes the graph data. Notably, sets the distance transform to all zeros.
      </li>
      <li class="icon solid fa-cogs">
        <code>bool isLoaded(const GridGraph& graph)</code>:
        Returns true if the graph has been loaded and false otherwise.
      </li>
      <li class="icon solid fa-cogs">
        <code>Cell posToCell(float x, float y, const GridGraph& graph)</code>:
        Given a global position <code>x</code> and <code>y</code>, in meters, calculates the corresponding cell in the graph.
      </li>
      <li class="icon solid fa-cogs">
        <code>std::vector<float> cellToPos(int i, int j, const GridGraph& graph)</code>:
        Given a cell in the graph, calculates the corresponding global position in meters.
      </li>
      <li class="icon solid fa-cogs">
        <code>bool isCellInBounds(int i, int j, const GridGraph& graph)</code>:
        Checks whether a given cell is in the bounds of the graph.
      </li>
      <li class="icon solid fa-cogs">
        <code>bool isIdxOccupied(int idx, const GridGraph& graph)</code>:
        Checks whether a given index is occupied.
      </li>
      <li class="icon solid fa-cogs">
        <code>bool isCellOccupied(int i, int j, const GridGraph& graph)</code>:
        Checks whether a given cell is occupied.
        <em>Warning:</em> This only works if <code>cellToIdx()</code> is implemented.
      </li>
      <li class="icon solid fa-cogs">
        <code>std::vector<int> findNeighbors(int idx, const GridGraph& graph)</code>:
        Returns a list of the indices of the neighbors of the cell at a given index in the graph.
        <em>Warning:</em> This only works if <code>cellToIdx()</code> and <code>idxToCell()</code> are implemented.
      </li>
    </ul>

    <p>The following structs are provided:</p>

    <ul class="hint">
      <li class="icon solid fa-cogs">
        <strong>Cell:</strong> For representing a cell in the graph.
        <pre><code class="language-cpp">struct Cell
{
float i, j;
};</code></pre>
        where <code>i</code> is the <em>row</em> of the cell, and <code>j</code> is the <em>columns</em> of the cell.
      </li>
      <li class="icon solid fa-cogs" id="code_utils_gridgraph">
        <strong>GridGraph:</strong> For storing map data.
        <pre><code class="language-cpp">struct GridGraph
{
GridGraph() :
width(-1),
height(-1),
origin_x(0),
origin_y(0),
meters_per_cell(0),
collision_radius(0.15),
threshold(-100)
{
};

int width, height;                      // Width and height of the map in cells.
float origin_x, origin_y;               // The (x, y) coordinate corresponding to cell (0, 0) in meters.
float meters_per_cell;                  // Width of a cell in meters.
float collision_radius;                 // The radius to use to check collisions.
int8_t threshold;                       // Threshold to check if a cell is occupied or not.

std::vector&lt;int8_t&gt; cell_odds;          // The odds that a cell is occupied.
std::vector&lt;float&gt; obstacle_distances;  // The distance from each cell to the nearest obstacle.
};</code></pre>
        The member variables <code>width</code> and <code>height</code> store the graph width and height, in cells. The variables <code>origin_x</code> and <code>origin_y</code> correspond to the global position in meters of the cell <code>(0, 0)</code>. This allows us to determine where the origin of the map is. The variable <code>meters_per_cell</code> contains the size of each cell, in meters. Finally, the <code>cell_odds</code> variable is a vector containing the odds value of each cell. The odds value and organization of the graph was covered in <a href="/files/labs/lab4_navigation_workflow.pdf">Lab 4</a>.
      </li>
    </ul>

  </section>

  <section id="proj_desc">
    <header class="major">
      <h2><a href="#proj_desc">Project Description</a></h2>
    </header>

    <p>This assignment has the following parts:</p>

    <ol>
      <li><a href="#sec_graph">Part 0</a>: Indexing into the Grid Graph</li>
      <li><a href="#sec_goal">Part 1</a>: Creating an attractive goal potential field</li>
      <li><a href="#sec_dt">Part 2</a>: Implementing the Distance Transform algorithm</li>
      <li><a href="#sec_pfield">Part 3</a>: Creating a potential field and performing navigation</li>
    </ol>

    <p>We also provide an advanced extension to implement the <a href="#sec_euclidean_dt">distance transform with Euclidean distance</a>, as discussed in lecture. Most of your time should be spent on Parts 2 and 3.</p>

    <p>We will be compiling and executing all the code written on your computer in a Docker container. We have created a web app which you can use to visualize your code. Review the <a href="/tutorials/app.html">webapp tutorial</a> and make sure that you can run the webapp in the Docker container before continuing with this assignment.</p>

    <h3 id="sec_graph">Part 0: Grid Graph</h3>

    <p>Information about the map for a particular environment is stored in a provided struct called <code>GridGraph</code>, described in <a href="#code_utils_gridgraph">the code overview</a>. You can visualize the available maps using the <a href="/tutorials/app.html">web app</a>.</p>

    <p>You should complete the functions <code>cellToIdx()</code> and <code>idxToCell()</code>, which convert between cells and indices as discussed in <a href="/files/labs/lab4_navigation_workflow.pdf">Lab 4</a>. You can use these functions for the following parts of the project.</p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo0_1">P2.0.1:</strong> In the file <code>graph_utils.cpp</code>, complete functions <code>cellToIdx()</code> and <code>idxToCell()</code>.
        <code>cellToIdx()</code> should accept a cell coordinate and a graph as arguments, and return an <code>int</code> containing the corresponding array index for the cell.
        <code>idxToCell()</code> should accept an array index and a graph as arguments, and return a <code>Cell</code> containing the corresponding cell coordinate for the array index.</li>
      </li>
    </ul>

    <p>We have provided a test script to check your indexing functions. Compile your code in the Docker container (using the <a href="/tutorials/app.html#write_code">instructions in the tutorial</a>), then run the test script in the Docker like this:</p>
    <pre><code class="language-bash">cd /code/build
cmake ..
make
./test_graph</code></pre>

    <p>The tests should pass before you move on to the next step. You may add more tests if you would like.</p>

    <h3 id="sec_goal">Part 1: The Goal Field</h3>

    <p>In this part, you will write an attractive field to pull the robot towards the goal location. You will test your function on the robot. You can also use the web app to test the function.</p>

    <p>First, complete function <code>createAttractiveField()</code> in file <code>src/potential_field/potential_field.cpp</code> so that it accepts the current graph and a goal cell and returns a vector representing the attractive field. The field should be a vector with the same length as the graph cell data, and should be indexed the same way.</p>

    <p>Next, modify the code in <code>src/robot_potential_field.cpp</code> so that it uses the function <code>createAttractiveField()</code> to drive to a goal. Create a map using the localization code provided, and pick a goal in that map. The template code uses the provided function <code>localSearch()</code> to get a 2D vector pointing towards the next location in the potential field to explore. Use this vector to create velocity commands to send to the robot. At this point, your robot will not be able to avoid obstacles, so make sure you pick a start and goal position so that your robot doesn't collide with anything.</p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo1_1">P2.1.1:</strong> In the file <code>potential_field.cpp</code>, complete function <code>createAttractiveField()</code> to return a vector corresponding to an attractive potential field towards a given goal.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong id="todo1_2">P2.1.2:</strong> Modify <code>robot_potential_field.cpp</code> so that it gets an attractive potential field to a goal, then drives in the direction returned by the <code>localSearch()</code> function. When the robot reaches a minimum in the field, <code>localSearch()</code> will return a vector of zeros. Test your code on the robot.
      </li>
    </ul>

    <ul class="hint">
      <li class="icon solid fa-cogs"><strong>Hint:</strong>
        An attractive field where the value of each cell is the distance to the goal location works when this is the only field.
      </li>
      <li class="icon solid fa-cogs"><strong>Hint:</strong>
        Use your indexing functions to convert between Cell types and indices, and your distance function to calculate distances between cells.
      </li>
      <li class="icon solid fa-cogs"><strong>Hint:</strong>
        You can visualize your attractive field in the web app by setting the vector <code>potential_field</code> in the function <code>createPotentialField()</code> to be equal to the attractive field. The field will be visualized when you plan using the &quot;Potential Field&quot; option in the web app.
      </li>
      <li class="icon solid fa-cogs"><strong>Hint:</strong>
        The local search function returns a vector containing three elements: <code>{vx, vy, grad}</code>. The first two, <code>vx</code> and <code>vy</code>, make a <em>unit vector</em> (with magnitude 1) pointing in the direction of the largest decrease in potential from the current location of the robot. The last element represents the magnitude of decrease in potential between the cell the robot is in, and the next cell in the direction of the vector. You might want to use it to control the velocity of the robot in your navigation algorithm.
      </li>
    </ul>

    <h3 id="sec_dt">Part 2: Distance Transform</h3>

    <p>In this part, you will implement a distance transform, which will calculate the distance from each cell to the nearest obstacle. This part can be implemented entirely on your computer in the Docker, using the web app (no robot needed). It should look something like the image below. The grey cells represent smaller distances to the nearest obstacle, and the white cells represent higher distances.</p>

    <span class="image main"><img src="/assets/images/p2/dist_tf.png" alt="" style="max-width:600px;"/></span>

    <p>We will be implementing a <strong>binary distance transform</strong>, which calculates the distance from each cell to the nearest occupied cell. For occupied cells, the distance should be zero.</p>

    <p>We will start by implementing a slow version of the distance transform which gives us the Euclidean distance to each cell. Implement this algorithm in the function <code>distanceTransformSlow()</code> located in <code>src/potential_field/distance_transform.cpp</code>. For each unoccupied cell, calculate the distance between the current cell and every occupied cell in the graph. Store the smallest distance in the <code>graph.obstacle_distances</code> vector.
      <!-- This implementation doesn't use any tricks to perform the transform more quickly. The complexity is <i>O(N<sup>2</sup>)</i> because the algorithm needs to loop through <i>N</i> cells for each of the <i>N</i> cells, resulting in <i>N*N = N<sup>2</sup></i> operations. You should notice that this takes a lot of time for big graphs! -->
    </p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo2_1">P2.2.1:</strong>
        In the <code>distance_transform.cpp</code> file, complete function <code>distanceTransformSlow()</code>. It should accept a graph and populate the <code>graph.obstacle_distances</code> vector with the Euclidean distance to the nearest occupied cell.
      </li>
    </ul>

    <p>You should make sure to test your algorithm on multiple different maps. You can use the web app to visualize the distances as a gradient. It should look like the image at the beginning of this page.</p>

    <ul class="hint">
      <li class="icon solid fa-cogs"><strong>Hint:</strong> You can visualize your transform in the web app by modifying the function <code>distanceTransform()</code> so that it calls <code>distanceTransformSlow()</code>. You should be able to see the distance transform when you toggle &quot;Show Field&quot; in the web app, after uploading the map file.</li>
      <li class="icon solid fa-cogs"><strong>Hint:</strong> Can you make your algorithm any faster?</li>
    </ul>

    <p>Next, we will implement a much faster algorithm for computing the distance transform, but which computes the Manhattan distance from each unoccupied cell to the nearest occupied cell. Implement this algorithm in the function <code>distanceTransformManhattan()</code> located in <code>src/potential_field/distance_transform.cpp</code>. You should implement the 2D Manhattan distance transform algorithm presented in lecture. You can visualize your distance transform by modifying the function <code>distanceTransform()</code> so that it calls <code>distanceTransformManhattan()</code>, just like for the slow version you completed.</p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo2_2">P2.2.2:</strong>
        In the <code>distance_transform.cpp</code> file, complete function <code>distanceTransformManhattan()</code>. It should accept a graph and populate the <code>graph.obstacle_distances</code> vector with the Manhattan distance to the nearest occupied cell, using the 2D Manhattan distance transform algorithm presented in lecture.
      </li>
    </ul>

    <h3 id="sec_pfield">Part 3: Potential Field Navigation</h3>

    <p>Now, you will combine the attractive field from <a href="#sec_goal">Part 1</a> and the distance transform from <a href="#sec_goal">Part 2</a> into a single potential field. Transform the distance transform stored in <code>graph.obstacle_distances</code> into a repulsive field in function <code>createRepulsiveField()</code> in file <code>src/potential_field/potential_field.cpp</code>. Then, modify <code>createPotentialField()</code> in the same file to combine the two. You might want to modify <code>createAttractiveField()</code> for this part.</p>

    <p>You should test your field in the web app, and when you are satisfied with the result, try it out on the robot. Modify the code in <code>src/robot_potential_field.cpp</code> to call the function <code>createPotentialField()</code>. The robot should now be able to navigate without colliding into obstacles. It will only avoid obstacles that are in its map, not dynamic obstacles, like people walking in front of it, so be careful!</p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todo3_1">P2.3.1:</strong>
        In the <code>potential_field.cpp</code> file, complete function <code>createRepulsiveField()</code>. It should create a repulsive field based on the distance transform in <code>graph.obstacle_distances</code>.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong id="todo3_2">P2.3.2:</strong>
        In the <code>potential_field.cpp</code> file, complete function <code>createPotentialField()</code>. It should combine the attractive and repulsive fields into a single potential field which can be used to navigate to a goal.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong id="todo3_3">P2.3.3:</strong>
        Modify the <code>robot_potential_field.cpp</code> file to use function <code>createPotentialField()</code> to get a potential field for a given map and goal, and navigate the robot using the field.
      </li>
    </ul>

    <ul class="hint">
      <li class="icon solid fa-cogs"><strong>Hint:</strong>
        The distance transform is HIGH in places that are far from an obstacle and LOW in places that are close to an obstacle. This is the opposite of the repulsive field, which should have HIGH potential near an obstacle and LOW potential far from an obstacle. What kind of function can you apply to the distances to convert the distance transform to a field?
      </li>
      <li class="icon solid fa-cogs"><strong>Hint:</strong>
        Experiment with a few different functions and parameters to find one that works. You should make sure that the function works for a variety of start and goal locations and maps.
      </li>
    </ul>

    <h3 id="sec_results">Project Webpage: Results &amp; Reflection Questions</h3>

    <p>On your project webpage, include a brief description (a few sentences) of your approach for each part. Include lots of images of how your algorithm works on the web app and the robot, as well as at least one video demo of your robot completing potential field navigation in <a href="sec_pfield">Part 3</a>. You might also consider taking videos of tests you complete on the web app using a screen recording software.</p>

    <p>Include a discussion section on the web page, where you discuss the following:</p>
    <ol>
      <li>The strengths of your potential field navigation algorithm</li>
      <li>The limitations of your potential field navigation algorithm</li>
      <li>How you might improve the algorithm (include at least one idea)</li>
    </ol>

    <p>In addition, consider these questions:</p>
    <ol>
      <li>Can you make the naive distance transform any faster (without implementing the fast algorithm we discussed in lecture)? If so, consider trying your idea!</li>
      <li>How does the Euclidean distance transform differ from the Manhattan one? How do they compare in terms of speed?</li>
      <li>What function did you select for your attrative and repulsive fields? How did you combine them to create a potential field?</li>
      <li>When and why does your potential field algorithm fail?</li>
    </ol>

    <p>Include images or videos whenever possible to illustrate your points. Keep the discussion brief: it should be no longer than two or three paragraphs.</p>

    <h3 id="sec_euclidean_dt">Advanced Extension: Euclidean Distance Transform</h3>

    <p>
      <strong>Notes on the algorithm:</strong> <a href="/files/lectures/fast_euclidean_dt.pdf">Fast Euclidean Distance Transform</a>.
      The notes describe an algorithm presented in a research paper which is available <a href="http://people.cs.uchicago.edu/~pff/papers/dt.pdf">here</a>.
    </p>

    <p>As an advanced extension, you can implement the fast Euclidean distance transform described in the notes linked above. The function <code>distanceTransformEuclidean2D()</code> is provided in the file <code>src/potential_field/distance_transform.cpp</code> to implement the algorithm. You may use function <code>distanceTransformEuclidean1D()</code> to implement the 1D version of the algorithm which is used within the 2D algorithm.</p>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong id="todoAE_2_i">Advanced Extension P2.2.i (2 extension points):</strong>
        In the <code>distance_transform.cpp</code> file, complete function <code>distanceTransformEuclidean2D()</code> so that it uses the fast Euclidean distance transform algorithm from lecture, and stores the result in <code>graph.obstacle_distances</code>.
      </li>
    </ul>

  </section>

  <!-- TASKS -->
  <section id="tasks">
    <header class="major">
      <h2><a href="#tasks">Task Summary</a></h2>
    </header>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo0">P2 License</a>:</strong>
        In the file <code>LICENSE.txt</code>, replace <code>&lt;COPYRIGHT HOLDER&gt;</code> with the names of all teammates, separated by commas.
        Replace <code>&lt;YEAR&gt;</code> with the current year.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo1">P2 Webpage</a>:</strong>
        Create a web page for your implementation of the potential field navigation algorithm. Include the link to your project page in the <code>README.md</code> file. Include at least one video demo as well as a brief summary and discussion of your algorithm.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo0_1">P2.0.1</a>:</strong>
        In the file <code>graph_utils.cpp</code>, complete functions <code>cellToIdx()</code> and <code>idxToCell()</code>.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo1_1">P2.1.1</a>:</strong>
        In the file <code>potential_field.cpp</code>, complete function <code>createAttractiveField()</code> to return a vector corresponding to an attractive potential field towards a given goal.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo1_2">P2.1.2</a>:</strong>
        Modify <code>robot_potential_field.cpp</code> so that it gets an attractive potential field to a goal, then drives in the direction returned by the <code>localSearch()</code> function. When the robot reaches a minimum in the field, <code>localSearch()</code> will return a vector of zeros. Test your code on the robot.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo2_1">P2.2.1</a>:</strong>
        In the <code>distance_transform.cpp</code> file, complete function <code>distanceTransformSlow()</code>. It should accept a graph and populate the <code>graph.obstacle_distances</code> vector with the Euclidean distance to the nearest occupied cell.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo2_2">P2.2.2</a>:</strong>
        In the <code>distance_transform.cpp</code> file, complete function <code>distanceTransformManhattan()</code>. It should accept a graph and populate the <code>graph.obstacle_distances</code> vector with the Manhattan distance to the nearest occupied cell, using the 2D Manhattan distance transform algorithm presented in lecture.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo3_1">P2.3.1</a>:</strong>
        In the <code>potential_field.cpp</code> file, complete function <code>createRepulsiveField()</code>. It should create a repulsive field based on the distance transform in <code>graph.obstacle_distances</code>.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo3_2">P2.3.2</a>:</strong>
        In the <code>potential_field.cpp</code> file, complete function <code>createPotentialField()</code>. It should combine the attractive and repulsive fields into a single potential field which can be used to navigate to a goal.
      </li>
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todo3_3">P2.3.3</a>:</strong>
        Modify the <code>robot_potential_field.cpp</code> file to use function <code>createPotentialField()</code> to get a potential field for a given map and goal, and navigate the robot using the field.
      </li>
    </ul>

  </section>

  <section id="adv_ext">
    <header class="major">
      <h2><a href="#adv_ext">Advanced Extensions</a></h2>
    </header>

    <ul class="todo">
      <li class="icon solid fa-laptop-code">
        <strong><a href="#todoAE_2_i">Advanced Extension P2.2.i</a> (2 extension points):</strong>
        In the <code>distance_transform.cpp</code> file, complete function <code>distanceTransformEuclidean2D()</code> so that it uses the fast Euclidean distance transform algorithm from lecture, and stores the result in <code>graph.obstacle_distances</code>.
      </li>
    </ul>

</section>


            </div>
          </div>

        <!-- Sidebar -->
          <div id="sidebar">
            <div class="inner">

              <!-- Menu -->
                <nav id="menu">
                  <header class="major">
                    <h2>Menu</h2>
                  </header>
                  <ul>
                    <li><a href="/index.html">Home</a></li>
                    <li>
                      <span class="opener">Course Information</span>
                      <ul>
                        <li><a href="/index.html#schedule">Schedule</a></li>
                        <li><a href="/index.html#office-hours">Office Hours</a></li>
                        <li><a href="/index.html#staff">Course Staff</a></li>
                        <li><a href="/syllabus.html">Syllabus</a></li>
                        <li><a href="/activities.html">Asynchronous Activities</a></li>
                      </ul>
                    </li>
                    <li>
                      <span class="opener">Projects</span>
                      <ul>
                        <li><a href="/projects/a0.html">Project 0: Pocket Calculator</a></li>
                        <li><a href="/projects/a1.html">Project 1: Wall Following</a></li>
                        <li><a href="/projects/a2.html">Project 2: Bug Navigation</a></li>
                        <li><a href="/projects/a3.html">Project 3: Path Planning</a></li>
                        <li><a href="/projects/a4.html">Project 4: Machine Learning</a></li>
                      </ul>
                    </li>
                    <li>
                      <span class="opener">Tutorials</span>
                      <ul>
                        <li><a href="/tutorials/setup.html">Computer Setup</a></li>
                        <li><a href="/tutorials/git.html">Github</a></li>
                        <li><a href="/tutorials/replit.html">Replit</a></li>
                        <li><a href="/tutorials/robot.html">Using the MBot-Omni</a></li>
                        <li><a href="/tutorials/app.html">Navigation Webapp</a></li>
                      </ul>
                    </li>
                    <li><a href="https://robotics102.github.io/nav-app/">Navigation Webapp</a></li>
                  </ul>
                </nav>

              <!-- Section -->
                <section>
                  <header class="major">
                    <h2>Course Times</h2>
                  </header>
                  <p>Lectures and labs</p>
                  <ul class="contact">
                    <li class="icon solid fa-chalkboard-teacher">TuTh 3-4:30 PM @ FRB 1060</li>
                    <li class="icon solid fa-flask">
                      F 10:30 AM-12:30 PM @ FRB 1060 <br/>
                      F 12:30-2:30 PM @ FRB 1060 <br/>
                      F 2:30-4:30 PM @ FRB 1060
                    </li>
                  </ul>
                </section>

              <!-- Footer -->
                <!-- <footer id="footer">
                  <p class="copyright">&copy; ROB 102. All rights reserved.</p>
                </footer> -->

            </div>
          </div>
        </div>

      </div>

    <!-- Scripts -->
      <script src="/assets/js/jquery.min.js"></script>
      <script src="/assets/js/browser.min.js"></script>
      <script src="/assets/js/breakpoints.min.js"></script>
      <script src="/assets/js/util.js"></script>
      <script src="/assets/js/main.js"></script>
      <script>hljs.highlightAll();</script>

  </body>
</html>
